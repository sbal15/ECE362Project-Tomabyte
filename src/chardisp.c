#include "pico/stdlib.h"
#include "hardware/spi.h"
#include "hardware/gpio.h"
#include "chardisp.h"

// External pin definitions
extern const int SPI_OLED_SCK;
extern const int SPI_OLED_MOSI;
extern const int SPI_OLED_CSn;
extern const int OLED_DC;
extern const int FEED_BUTTON;

#define OLED_SPI spi1

// OLED display dimensions
#define OLED_WIDTH 128
#define OLED_HEIGHT 128

//pet states
typedef enum {
    STATE_NORMAL,
    STATE_HUNGRY
} PetState;

static PetState pet_state = STATE_NORMAL;
static alarm_id_t hunger_alarm_id;



// Basic 6x8 ASCII font (characters 32–127)
static const uint8_t font6x8[96][6] = {
    // Each char = 6 bytes (columns), LSB at top
    {0x00,0x00,0x00,0x00,0x00,0x00}, // 32 ' '
    {0x00,0x00,0x5F,0x00,0x00,0x00}, // 33 '!'
    {0x00,0x07,0x00,0x07,0x00,0x00}, // 34 '"'
    {0x14,0x7F,0x14,0x7F,0x14,0x00}, // 35 '#'
    {0x24,0x2A,0x7F,0x2A,0x12,0x00}, // 36 '$'
    {0x23,0x13,0x08,0x64,0x62,0x00}, // 37 '%'
    {0x36,0x49,0x55,0x22,0x50,0x00}, // 38 '&'
    {0x00,0x05,0x03,0x00,0x00,0x00}, // 39 '''
    {0x00,0x1C,0x22,0x41,0x00,0x00}, // 40 '('
    {0x00,0x41,0x22,0x1C,0x00,0x00}, // 41 ')'
    {0x14,0x08,0x3E,0x08,0x14,0x00}, // 42 '*'
    {0x08,0x08,0x3E,0x08,0x08,0x00}, // 43 '+'
    {0x00,0x50,0x30,0x00,0x00,0x00}, // 44 ','
    {0x08,0x08,0x08,0x08,0x08,0x00}, // 45 '-'
    {0x00,0x60,0x60,0x00,0x00,0x00}, // 46 '.'
    {0x20,0x10,0x08,0x04,0x02,0x00}, // 47 '/'
    {0x3E,0x51,0x49,0x45,0x3E,0x00}, // 48 '0'
    {0x00,0x42,0x7F,0x40,0x00,0x00}, // 49 '1'
    {0x42,0x61,0x51,0x49,0x46,0x00}, // 50 '2'
    {0x21,0x41,0x45,0x4B,0x31,0x00}, // 51 '3'
    {0x18,0x14,0x12,0x7F,0x10,0x00}, // 52 '4'
    {0x27,0x45,0x45,0x45,0x39,0x00}, // 53 '5'
    {0x3C,0x4A,0x49,0x49,0x30,0x00}, // 54 '6'
    {0x01,0x71,0x09,0x05,0x03,0x00}, // 55 '7'
    {0x36,0x49,0x49,0x49,0x36,0x00}, // 56 '8'
    {0x06,0x49,0x49,0x29,0x1E,0x00}, // 57 '9'
    {0x00,0x36,0x36,0x00,0x00,0x00}, // 58 ':'
    {0x00,0x56,0x36,0x00,0x00,0x00}, // 59 ';'
    {0x08,0x14,0x22,0x41,0x00,0x00}, // 60 '<'
    {0x14,0x14,0x14,0x14,0x14,0x00}, // 61 '='
    {0x00,0x41,0x22,0x14,0x08,0x00}, // 62 '>'
    {0x02,0x01,0x51,0x09,0x06,0x00}, // 63 '?'
    {0x32,0x49,0x79,0x41,0x3E,0x00}, // 64 '@'
    {0x7E,0x11,0x11,0x11,0x7E,0x00}, // 65 'A'
    {0x7F,0x49,0x49,0x49,0x36,0x00}, // 66 'B'
    {0x3E,0x41,0x41,0x41,0x22,0x00}, // 67 'C'
    {0x7F,0x41,0x41,0x22,0x1C,0x00}, // 68 'D'
    {0x7F,0x49,0x49,0x49,0x41,0x00}, // 69 'E'
    {0x7F,0x09,0x09,0x09,0x01,0x00}, // 70 'F'
    {0x3E,0x41,0x49,0x49,0x7A,0x00}, // 71 'G'
    {0x7F,0x08,0x08,0x08,0x7F,0x00}, // 72 'H'
    {0x00,0x41,0x7F,0x41,0x00,0x00}, // 73 'I'
    {0x20,0x40,0x41,0x3F,0x01,0x00}, // 74 'J'
    {0x7F,0x08,0x14,0x22,0x41,0x00}, // 75 'K'
    {0x7F,0x40,0x40,0x40,0x40,0x00}, // 76 'L'
    {0x7F,0x02,0x0C,0x02,0x7F,0x00}, // 77 'M'
    {0x7F,0x04,0x08,0x10,0x7F,0x00}, // 78 'N'
    {0x3E,0x41,0x41,0x41,0x3E,0x00}, // 79 'O'
    {0x7F,0x09,0x09,0x09,0x06,0x00}, // 80 'P'
    {0x3E,0x41,0x51,0x21,0x5E,0x00}, // 81 'Q'
    {0x7F,0x09,0x19,0x29,0x46,0x00}, // 82 'R'
    {0x46,0x49,0x49,0x49,0x31,0x00}, // 83 'S'
    {0x01,0x01,0x7F,0x01,0x01,0x00}, // 84 'T'
    {0x3F,0x40,0x40,0x40,0x3F,0x00}, // 85 'U'
    {0x1F,0x20,0x40,0x20,0x1F,0x00}, // 86 'V'
    {0x3F,0x40,0x38,0x40,0x3F,0x00}, // 87 'W'
    {0x63,0x14,0x08,0x14,0x63,0x00}, // 88 'X'
    {0x07,0x08,0x70,0x08,0x07,0x00}, // 89 'Y'
    {0x61,0x51,0x49,0x45,0x43,0x00}, // 90 'Z'
    {0x00,0x20,0x54,0x54,0x78,0x00}, // 97 'a'
    {0x7F,0x48,0x44,0x44,0x38,0x00}, // 98 'b'
    {0x38,0x44,0x44,0x44,0x20,0x00}, // 99 'c'
    {0x38,0x44,0x44,0x48,0x7F,0x00}, // 100 'd'
    {0x38,0x54,0x54,0x54,0x18,0x00}, // 101 'e'
    {0x08,0x7E,0x09,0x01,0x02,0x00}, // 102 'f'
    {0x0C,0x52,0x52,0x52,0x3E,0x00}, // 103 'g'
    {0x7F,0x08,0x04,0x04,0x78,0x00}, // 104 'h'
    {0x00,0x44,0x7D,0x40,0x00,0x00}, // 105 'i'
    {0x20,0x40,0x44,0x3D,0x00,0x00}, // 106 'j'
    {0x7F,0x10,0x28,0x44,0x00,0x00}, // 107 'k'
    {0x00,0x41,0x7F,0x40,0x00,0x00}, // 108 'l'
    {0x7C,0x04,0x18,0x04,0x78,0x00}, // 109 'm'
    {0x7C,0x08,0x04,0x04,0x78,0x00}, // 110 'n'
    {0x38,0x44,0x44,0x44,0x38,0x00}, // 111 'o'
    {0x7C,0x14,0x14,0x14,0x08,0x00}, // 112 'p'
    {0x08,0x14,0x14,0x18,0x7C,0x00}, // 113 'q'
    {0x7C,0x08,0x04,0x04,0x08,0x00}, // 114 'r'
    {0x48,0x54,0x54,0x54,0x20,0x00}, // 115 's'
    {0x04,0x3F,0x44,0x40,0x20,0x00}, // 116 't'
    {0x3C,0x40,0x40,0x20,0x7C,0x00}, // 117 'u'
    {0x1C,0x20,0x40,0x20,0x1C,0x00}, // 118 'v'
    {0x3C,0x40,0x30,0x40,0x3C,0x00}, // 119 'w'
    {0x44,0x28,0x10,0x28,0x44,0x00}, // 120 'x'
    {0x0C,0x50,0x50,0x50,0x3C,0x00}, // 121 'y'
    {0x44,0x64,0x54,0x4C,0x44,0x00}, // 122 'z'
    // (truncated for brevity — optional: add remaining ASCII)
};

// -----------------------------
// SPI + GPIO setup
// -----------------------------
void init_oled_pins() { //initializing SPI peripheral
    spi_init(OLED_SPI, 10 * 1000 * 1000); // 10 MHz SPI
    gpio_set_function(SPI_OLED_SCK, GPIO_FUNC_SPI);
    gpio_set_function(SPI_OLED_MOSI, GPIO_FUNC_SPI);

    gpio_init(SPI_OLED_CSn);
    gpio_set_dir(SPI_OLED_CSn, GPIO_OUT); //CSn = out
    gpio_put(SPI_OLED_CSn, 1); //set Csn

    gpio_init(OLED_DC);
    gpio_set_dir(OLED_DC, GPIO_OUT); //DC = out
}

// -----------------------------
// Low-level SPI helpers
// -----------------------------
void oled_write_cmd(uint8_t cmd) {
    gpio_put(OLED_DC, 0); // DC: Command mode
    gpio_put(SPI_OLED_CSn, 0);
    spi_write_blocking(OLED_SPI, &cmd, 1);
    gpio_put(SPI_OLED_CSn, 1);
}

void oled_write_data(uint8_t data) {
    gpio_put(OLED_DC, 1); // DC: Data mode
    gpio_put(SPI_OLED_CSn, 0);
    spi_write_blocking(OLED_SPI, &data, 1);
    gpio_put(SPI_OLED_CSn, 1);
}

// -----------------------------
// SSD1351 initialization sequence
// -----------------------------
void oled_init() {
    sleep_ms(10);

    oled_write_cmd(0xFD); // Command lock
    oled_write_data(0x12);
    oled_write_cmd(0xFD);
    oled_write_data(0xB1);

    oled_write_cmd(0xAE); // Display off
    oled_write_cmd(0xB3);
    oled_write_data(0xF1); // Clock div

    oled_write_cmd(0xCA);
    oled_write_data(0x7F); // MUX ratio (128)

    oled_write_cmd(0xA0);
    oled_write_data(0x74); // RGB color remap

    oled_write_cmd(0xA1);
    oled_write_data(0x00); // Column start

    oled_write_cmd(0xA2);
    oled_write_data(0x00); // Row start

    oled_write_cmd(0xB5);
    oled_write_data(0x00); // GPIO off

    oled_write_cmd(0xAB);
    oled_write_data(0x01); // Enable internal VDD regulator

    oled_write_cmd(0xB1);
    oled_write_data(0x32); // Set precharge

    oled_write_cmd(0xBE);
    oled_write_data(0x05); // VCOMH

    oled_write_cmd(0xA6); // Normal display
    oled_write_cmd(0xC1);
    oled_write_data(0xC8);
    oled_write_data(0x80);
    oled_write_data(0xC8);

    oled_write_cmd(0xC7);
    oled_write_data(0x0F); // Contrast

    oled_write_cmd(0xAF); // Display ON
    sleep_ms(100);
}

// -----------------------------
// Simple drawing helpers
// -----------------------------
void oled_set_window(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) { //defines rect region where pixel data is written
    oled_write_cmd(0x15); // Column
    oled_write_data(x0);
    oled_write_data(x1);

    oled_write_cmd(0x75); // Row
    oled_write_data(y0);
    oled_write_data(y1);
}

void oled_fill(uint16_t color) { //fills entire screen with one color
    oled_set_window(0, 0, OLED_WIDTH - 1, OLED_HEIGHT - 1);
    oled_write_cmd(0x5C);

    gpio_put(OLED_DC, 1);
    gpio_put(SPI_OLED_CSn, 0);
    uint8_t buffer[2] = { color >> 8, color & 0xFF };
    for (int i = 0; i < OLED_WIDTH * OLED_HEIGHT; i++)
        spi_write_blocking(OLED_SPI, buffer, 2);
    gpio_put(SPI_OLED_CSn, 1);
}


//draws the defined letters (above) for us
//y --> can go in forms of 1, 16, 32, 64, 128
//implemented lowercase letters now
void oled_draw_text_scaled(uint8_t x, uint8_t y, const char *text, uint16_t color, uint16_t bg, uint8_t scale) {
    while (*text) {
        char c = *text++;
        if (c < 32 || c > 127)
            c = '?';

        const uint8_t *glyph = font6x8[c - 32];

        for (int row = 0; row < 8; row++) {
            for (int srow = 0; srow < scale; srow++) {
                for (int col = 0; col < 6; col++) {
                    uint8_t line = glyph[col];
                    uint16_t drawColor = (line & (1 << row)) ? color : bg;
                    for (int scol = 0; scol < scale; scol++) {
                        oled_set_window(x + col * scale + scol, y + row * scale + srow, 
                                        x + col * scale + scol, y + row * scale + srow);
                        oled_write_cmd(0x5C);
                        oled_write_data(drawColor >> 8);
                        oled_write_data(drawColor & 0xFF);
                    }
                }
            }
        }

        x += 6 * scale;
        if (x + 6 * scale >= OLED_WIDTH) {
            x = 0;
            y += 8 * scale;
        }
    }
}

// 16x16 tomabyte draft (default)
const uint16_t pet_sprite[16 * 16] = {
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 
	0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};

const uint16_t pet_sprite_hungry[16 * 16] = {
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 
	0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 
	0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 
	0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};



void oled_draw_start_screen() {
    oled_fill(0xFFFF); // white background

    //oled_draw_text_scaled(10, 10, "TOMAGOTCHI", 0xFFFF, 0x0000, 2);

    // Draw pet sprite in center(if hungry, draw hungry bitmap)
    if (pet_state == STATE_NORMAL) {
        oled_draw_sprite_scaled(56, 50, pet_sprite, 16, 16, 4);
    } else {
        oled_draw_sprite_scaled(56, 50, pet_sprite_hungry, 16, 16, 4);
    }
    //oled_draw_text_scaled(10, 90, "PRESS FEED OR PLAY", 0xF800, 0x0000, 1);
    //oled_draw_text_scaled(10, 105, "TO START", 0xF800, 0x0000, 1);
}

void oled_draw_sprite_scaled(uint8_t x, uint8_t y, const uint16_t *sprite, uint8_t w, uint8_t h, uint8_t scale) {
    for (int row = 0; row < h; row++) {
        for (int col = 0; col < w; col++) {
            uint16_t color = sprite[row * w + col];

            // Draw a block of pixels for scaling
            for (int dy = 0; dy < scale; dy++) {
                for (int dx = 0; dx < scale; dx++) {
                    uint8_t px = x + col * scale + dx;
                    uint8_t py = y + row * scale + dy;

                    oled_set_window(px, py, px, py);
                    oled_write_cmd(0x5C);
                    oled_write_data(color >> 8);
                    oled_write_data(color & 0xFF);
                }
            }
        }
    }
}
int64_t hunger_callback(alarm_id_t id, void *user_data) {
    pet_state = STATE_HUNGRY;
    oled_draw_start_screen();
    // sad_sound(); //optional buzzer sound
    return 0; // one-shot
}

void reset_hunger_timer() {
    // Cancel old alarm if active
    cancel_alarm(hunger_alarm_id);
    // Schedule new alarm in 60,000 ms (1 min)
    hunger_alarm_id = add_alarm_in_ms(10000, hunger_callback, NULL, false);
}

void check_feed_button() {
    if (!gpio_get(FEED_BUTTON)) { // active low
        pet_state = STATE_NORMAL;
        oled_draw_start_screen();
        reset_hunger_timer();
        // happy_sound(); //optional happy sound
        sleep_ms(200); // debounce
    }
}

void init_feed_button() {
    gpio_init(FEED_BUTTON);
    gpio_set_dir(FEED_BUTTON, GPIO_IN);
    gpio_pull_up(FEED_BUTTON); // stable high when not pressed
}

